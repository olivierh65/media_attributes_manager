<?php

namespace Drupal\media_attributes_manager\FieldHandler;

use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Entity\FieldableEntityInterface;
use Drupal\Core\Form\FormStateInterface;

/**
 * Gestionnaire de champs personnalisés pour les médias.
 *
 * Cette classe organise et traite les champs personnalisés par type d'entité,
 * facilitant l'édition en masse de plusieurs types de médias à la fois.
 */
class CustomFieldHandler {

  /**
   * @var \Drupal\Core\Entity\EntityFieldManagerInterface
   */
  protected $entityFieldManager;

  /**
   * @var \Drupal\Core\Logger\LoggerChannelInterface
   */
  protected $logger;

  /**
   * Constructeur avec injection de dépendances.
   */
  public function __construct($entity_field_manager, $logger_factory) {
    $this->entityFieldManager = $entity_field_manager;
    $this->logger = $logger_factory->get('media_attributes_manager');
  }

  /**
   * Construit la partie du formulaire pour les champs personnalisés.
   *
   * @param array $form
   *   Le formulaire à modifier.
   * @param array $media_entities
   *   Tableau d'entités média à éditer.
   *
   * @return array
   *   Formulaire modifié.
   */
  public function buildCustomFieldsForm(array $form, array $media_entities) {
    if (empty($media_entities)) {
      return $form;
    }

    // Groupe les médias par bundle
    $media_by_bundle = [];
    foreach ($media_entities as $media) {
      $bundle = $media->bundle();
      if (!isset($media_by_bundle[$bundle])) {
        $media_by_bundle[$bundle] = [];
      }
      $media_by_bundle[$bundle][] = $media;
    }

    // Crée des sous-formulaires pour chaque type de média
    $form['custom_fields'] = [
      '#type' => 'vertical_tabs',
      '#title' => t('Custom fields by media type'),
    ];

    foreach ($media_by_bundle as $bundle => $bundle_media_list) {
      $form['custom_fields'][$bundle] = [
        '#type' => 'details',
        '#title' => t('@bundle attributes', ['@bundle' => ucfirst($bundle)]),
        '#group' => 'custom_fields',
      ];

      // Ajoute les champs disponibles pour ce type de média
      $field_definitions = $this->entityFieldManager->getFieldDefinitions('media', $bundle);
      
      foreach ($field_definitions as $field_name => $definition) {
        // Filtrer les champs système et non modifiables
        if ($definition->isReadOnly() || in_array($field_name, ['id', 'uuid', 'vid', 'revision_id'])) {
          continue;
        }
        
        // Crée le champ approprié selon le type
        $form['custom_fields'][$bundle][$field_name] = $this->createFieldWidget($field_name, $definition, $bundle_media_list);
        
        // Ajoute un checkbox pour effacer le champ
        $form['custom_fields'][$bundle][$field_name . '_clear'] = [
          '#type' => 'checkbox',
          '#title' => t('Clear @field', ['@field' => $definition->getLabel()]),
          '#default_value' => FALSE,
        ];
      }
    }

    return $form;
  }

  /**
   * Crée le widget approprié pour un champ selon son type.
   *
   * @param string $field_name
   *   Nom du champ.
   * @param \Drupal\Core\Field\FieldDefinitionInterface $definition
   *   Définition du champ.
   * @param array $entities
   *   Entités qui ont ce champ.
   *
   * @return array
   *   Configuration du widget de formulaire.
   */
  protected function createFieldWidget($field_name, $definition, array $entities) {
    // Logique pour créer le widget approprié selon le type de champ
    // et la cardinalité (texte, référence d'entité, booléen, etc.)
    
    // Example simplifié
    $widget = [
      '#type' => 'textfield',
      '#title' => $definition->getLabel(),
      '#description' => $definition->getDescription(),
      '#required' => FALSE,
    ];
    
    // Logique plus complexe basée sur getType() du définition
    // et les valeurs actuelles dans les entités
    
    return $widget;
  }

  /**
   * Traite les valeurs soumises pour mettre à jour les entités.
   *
   * @param array $form_values
   *   Valeurs soumises du formulaire.
   * @param array $media_entities
   *   Entités média à mettre à jour.
   *
   * @return int
   *   Nombre d'entités modifiées.
   */
  public function processSubmittedValues(array $form_values, array $media_entities) {
    $updated_count = 0;
    
    foreach ($media_entities as $media) {
      $bundle = $media->bundle();
      $updated = FALSE;
      
      // Si on a des valeurs pour ce bundle
      if (isset($form_values['custom_fields'][$bundle])) {
        $bundle_values = $form_values['custom_fields'][$bundle];
        
        // Traiter chaque champ
        foreach ($bundle_values as $field_name => $value) {
          // Ignorer les champs de type _clear
          if (strpos($field_name, '_clear') !== FALSE) {
            continue;
          }
          
          $clear_field_name = $field_name . '_clear';
          
          // Effacer le champ si demandé
          if (!empty($bundle_values[$clear_field_name])) {
            try {
              $media->{$field_name} = NULL;
              $updated = TRUE;
            } 
            catch (\Exception $e) {
              $this->logger->error('Error clearing field @field: @error', [
                '@field' => $field_name,
                '@error' => $e->getMessage(),
              ]);
            }
          }
          // Sinon mettre à jour avec la nouvelle valeur
          elseif (!empty($value)) {
            try {
              $media->{$field_name} = $value;
              $updated = TRUE;
            }
            catch (\Exception $e) {
              $this->logger->error('Error updating field @field: @error', [
                '@field' => $field_name,
                '@error' => $e->getMessage(),
              ]);
            }
          }
        }
        
        // Sauvegarder l'entité si elle a été modifiée
        if ($updated) {
          try {
            $media->save();
            $updated_count++;
          }
          catch (\Exception $e) {
            $this->logger->error('Error saving media @id: @error', [
              '@id' => $media->id(),
              '@error' => $e->getMessage(),
            ]);
          }
        }
      }
    }
    
    return $updated_count;
  }
}
